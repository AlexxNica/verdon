#!/usr/bin/env node

/* jshint esversion: 6, node: true */

'use strict';

// TODO: Shorten description of commands to single line.
// TODO: Rename commands to more explicit names (e.g. start-mock-server).
// TODO: Add command to check compatibility of two protocols.

const chalk = require('chalk');
const commander = require('commander');
const actions = require('../lib/actions');
const utils = require('../lib/utils');


commander
  .usage('\r  Usage:  verdon <command> [options] [<args> ...]')
  .version(require('../package').version)
  .action(exiting(function (cmd, opts, cb) {
    // Default handler, called when none of the commands below match.
    cb(new Error(`unknown command \`${cmd}'`));
  }));

commander.command('assemble')
  .description(utils.indent(`
    Assemble a protocol's IDL specification at path <protocol> into its
    corresponding JSON representation. If <type> is specified, this type's
    schema will be output instead.
  `, 2))
  .arguments('<protocol> [<type>]')
  .action(exiting(actions.assemble));

commander.command('call')
  .description(utils.indent(`
    Send a message to a remote service listening at <url>. If no <request> is
    specified, it will be read from standard in.
  `, 2))
  .arguments('<url> <message> [<request>]')
  .option('--header <key:type:value>', 'JSON header', collectHeaders, [])
  .option('--protocol <path>', 'path to local protocol')
  .option('--scope <string>', 'remote service scope')
  .option('--transport <path>', 'path to transport module')
  .action(exiting(actions.call));

commander.command('info')
  .description(utils.indent(`
    Retrieve a remote service's protocol and expose it in various forms.
  `, 2))
  .arguments('<url> [<message>]')
  .option('--json', 'output JSON')
  .option('--scope <string>', 'remote service scope')
  .action(exiting(actions.info));

commander.command('serve')
  .description(utils.indent(`
    Create a fake server.
  `, 2))
  .arguments('<address> <protocol>')
  .option('--scope <string>', 'service scope')
  .action(exiting(actions.serve));

/** Wrap a function such that it exits when an error occurs. */
function exiting(fn) {
  return function () {
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    args.push(function (err, str) {
      if (err) {
        const msg = chalk.red(err instanceof Error ?
          err.message :
          JSON.stringify(err));
        console.error(`\n  error: ${msg}`);
        process.exit(1);
      }
      if (str) {
        console.log(str);
      }
    });
    // Note that the penultimate argument is the command itself (which we can
    // use directly as an options object!).
    return fn.apply(this, args);
  };
}

/** Gather and serialize headers. */
function collectHeaders(hdr, acc) {
  // --header 'key:type=jsonVal' or --header key=stringVal
  const prefixEnd = hdr.indexOf('=');
  if (!~prefixEnd) {
    throw new Error(`invalid header: ${hdr}`);
  }
  const prefix = hdr.slice(0, prefixEnd);
  const suffix = hdr.slice(prefixEnd + 1);
  const keyEnd = prefix.indexOf(':');
  acc.push(~keyEnd ?
    {
      key: prefix.slice(0, keyEnd),
      name: prefix.slice(keyEnd + 1),
      val: suffix
    } :
    {
      key: prefix,
      name: 'string',
      val: `"${suffix}"` // Make this a valid JSON string.
    });
  return acc;
}

if (process.argv.length > 2) {
  commander.parse(process.argv);
} else {
  // By default, commander lets missing arguments through.
  commander.outputHelp();
  process.exit(2);
}

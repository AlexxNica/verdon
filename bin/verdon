#!/usr/bin/env node

/* jshint esversion: 6, node: true */

'use strict';

const commander = require('commander');
const verdon = require('../lib');

commander
  .usage('verdon <command> [options] [<args> ...]')
  .version(require('../package').version)
  .action(function (cmd) {
    // Default handler, called when none of the commands below match.
    console.error(`  error: unknown command \`${cmd}'`);
    process.exit(3);
  });

commander.command('call')
  .description(trim(`
    Send a message to a remote service listening at <url>. If no <request> is
    specified, it will be read from standard in.
  `))
  .arguments('<url> <message> [<request>]')
  .option('-p, --protocol <path>', 'path to local protocol')
  .option('-s, --scope <string>', 'remote service scope')
  .option('-t, --transport <path>', 'path to transport module')
  .action(exiting(verdon.call));

commander.command('info')
  .description(trim(`
    Retrieve a remote service's protocol and expose it in various forms.
  `))
  .arguments('<url> [<message>]')
  .option('-j, --json', 'output JSON')
  .option('-s, --scope <string>', 'remote service scope')
  .action(exiting(verdon.info));

commander.command('serve')
  .description(trim(`
    Create a fake server.
  `))
  .arguments('<url> <protocol>')
  .option('-s, --scope <string>', 'service scope')
  .action(exiting(verdon.serve));

/** Trim description such that it aligns nicely with commander's defaults. */
function trim(str) { return str.replace(/^  /gm, ''); }

/** Wrap a function such that it exits when an error occurs. */
function exiting(fn) {
  return function () {
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    args.push(function (err, str) {
      if (err) {
        console.error(`  error: ${err.message || err.toString()}`);
        process.exit(1);
      }
      console.log(str);
    });
    // Note that the penultimate argument is the command itself (which we can
    // use directly as an options object!).
    return fn.apply(this, args);
  };
}

if (process.argv.length > 2) {
  commander.parse(process.argv);
} else {
  // By default, commander lets missing arguments through.
  commander.outputHelp();
  process.exit(2);
}

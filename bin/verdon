#!/usr/bin/env node

/* jshint esversion: 6, node: true */

'use strict';

// TODO: Shorten description of commands to single line.
// TODO: Rename commands to more explicit names (e.g. start-mock-server).
// TODO: Add command to check compatibility of two protocols.

const actions = require('../lib/actions');

const chalk = require('chalk');
const commander = require('commander');
const paramCase = require('param-case');

commander
  .usage('\r  Usage:  verdon <command> [options] [<args> ...]')
  .version(require('../package').version)
  .action(exiting(function () {
    // Default handler, called when none of the commands below match. Note that
    // `arguments` is guaranteed to have at least length 1 (from `exiting`).
    const cb = arguments[arguments.length - 1];
    const err = new Error(
      arguments.length > 1 ?
      `unknown command \`${arguments[0]}'` :
      'invalid command');
    cb(err);
  }));

addActions(commander, [
  {
    name: 'call',
    args: '<url> <message> [<request>]',
    opts: [
      ['--header <key:type:value>', 'JSON header', collectHeaders, []],
      ['--protocol <path>', 'path to local protocol'],
      ['--scope <string>', 'remote server scope']
    ]
  },
  {
    name: 'info',
    args: '<url>',
    opts: [
      ['--message <name>', 'message'],
      ['--type <name>', 'type'],
      ['--json', 'output schema'],
      ['--scope <string>', 'remote server scope']
    ]
  },
  {
    name: 'startProxy',
    args: '<path>',
    opts: [
      ['--port <port>', 'port'],
      ['--scope <string>', 'remote server scope']
    ]
  }
]);

// Helpers.

/** Gather and serialize headers. */
function collectHeaders(hdr, acc) {
  // --header 'key:type=jsonVal' or --header key=stringVal
  const prefixEnd = hdr.indexOf('=');
  if (!~prefixEnd) {
    throw new Error(`invalid header: ${hdr}`);
  }
  const prefix = hdr.slice(0, prefixEnd);
  const suffix = hdr.slice(prefixEnd + 1);
  const keyEnd = prefix.indexOf(':');
  acc.push(~keyEnd ?
    {
      key: prefix.slice(0, keyEnd),
      name: prefix.slice(keyEnd + 1),
      val: suffix
    } :
    {
      key: prefix,
      name: 'string',
      val: `"${suffix}"` // Make this a valid JSON string.
    });
  return acc;
}

/** Wrap a function such that it exits when an error occurs. */
function exiting(fn) {
  return function () {
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    args.push(function (err, str) {
      if (err) {
        const msg = chalk.red(err instanceof Error ?
          err.message :
          JSON.stringify(err));
        console.error(`\n  error: ${msg}`);
        process.exit(1);
      }
      if (str) {
        console.log(str);
      }
    });
    // Note that the penultimate argument is the command itself (which we can
    // use directly as an options object!).
    return fn.apply(this, args);
  };
}

/** Register a command corresponding to an action. */
function addActions(prog, arr) {
  for (const params of arr) {
    const cmd = prog.command(paramCase(params.name))
      .action(exiting(actions[params.name]))
      .arguments(params.args);
    for (const opt of params.opts || []) {
      cmd.option.apply(cmd, opt);
    }
  }
}

if (process.argv.length > 2) {
  commander.parse(process.argv);
} else {
  // By default, commander lets missing arguments through.
  commander.outputHelp();
  process.exit(2);
}

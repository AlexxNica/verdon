#!/usr/bin/env node

/* jshint esversion: 6, node: true */

'use strict';

const commander = require('commander');
const verdon = require('../lib');

commander.version(require('../package').version);

commander.command('call')
  .description(trim(`
    Send a message to a remote service listening at <url>. If no <request> is
    specified, it will be read from standard in.
  `))
  .arguments('<url> <message> [<request>]')
  .option('-p, --protocol <path>', 'path to local protocol')
  .option('-t, --transport <path>', 'path to transport module')
  .action(exiting(verdon.call));

commander.command('info')
  .description(trim(`
    Retrieve a remote service's protocol and expose it in various forms.
  `))
  .arguments('<url> [<message>]')
  .option('-j, --json', 'output JSON')
  .action(exiting(verdon.info));

/** Trim description such that it aligns nicely with commander's defaults. */
function trim(str) { return str.replace(/^  /gm, ''); }

/** Wrap a function such that it exits when an error occurs. */
function exiting(fn) {
  return function () {
    const args = [];
    for (let i = 0; i < arguments.length; i++) {
      args[i] = arguments[i];
    }
    args.push(function (err) {
      if (err) {
        console.error('  error: ' + (err.message || err.toString()));
        process.exit(1);
      }
    });
    // Note that the penultimate argument it the command itself (which we can
    // use directly as an options object!).
    return fn.apply(this, args);
  };
}

commander.parse(process.argv);
